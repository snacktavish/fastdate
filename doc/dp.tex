% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{breqn}
\usepackage{a4wide}
\usepackage{natbib}
\usepackage[normalem]{ulem} % for \sout to strikethrough text
\newcounter{instr}
\newcommand{\ninstr}{\refstepcounter{instr}\theinstr.}

\newcommand{\ejmcomment}[1]{{\color{green} #1}}

\newcommand{\mthcomment}[1]{{[\color{red}MTH comment: #1]}}
\newcommand{\mthstrike}[1]{{\color{red}\sout{#1}}}
\usepackage{hyperref}
\hypersetup{linkcolor=blue, citecolor=red, colorlinks=true}


\linespread{1.66}
% All text should be double-spaced
% with occasional exceptions for tables. 
\raggedright
\setlength{\parindent}{0.5in}

\setcounter{secnumdepth}{0}
% Our sections are not numbered and our papers do not have
% Tables of Contents. We don't 
% present a list of figures or list of tables, either.

% Any common font is fine.
% (A common sans-serif font should be used on figures, but figures should be
% separate from the LaTeX document.)

\pagestyle{empty}

\renewcommand{\section}[1]{%
\bigskip
\begin{center}
\begin{Large}
\normalfont\scshape #1
\medskip
\end{Large}
\end{center}}

\renewcommand{\subsection}[1]{%
\bigskip
\begin{center}
\begin{large}
\normalfont\itshape #1
\end{large}
\end{center}}

\renewcommand{\subsubsection}[1]{%
\vspace{2ex}
\noindent
\textit{#1.}---}

\renewcommand{\tableofcontents}{}

\bibpunct{(}{)}{;}{a}{}{,}  % this is a citation format command for natbib
%%for the moment writing up as targeted for sys bio software paper
%Software for Systematics and Evolution Articles
%Submissions should describe new or original software or tools that provide new analytical capabilities to the end user. 
%Submissions may also be considered that describe new versions of existing software, 
%provided that the new version makes significant changes to function or performance 
%(for example, a version that implements new and important methods in addition 
%to those previously provided in a software package might be considered for publication). 
%Publication will be determined largely based on the software or tool itself, 
%so working links to a functional copy must be provided at the time of submission.
%Additional requirements: 
%The software or tool must well documented and easy to use for the typical user. 
%The manuscript itself must be readable by the general Systematic Biology readership. 
%If relevant, the manuscript must include benchmark data, 
%or refer to Supplemental Material that includes such data. 
%If appropriate, such benchmarking should include real biological data and a comparison with related tools. 
%If appropriate, the submission must include working sample data files. 
%Any software must be open source, web-distributed and free to non-commercial users. 
%In addition, the authors must certify that they will provide support 
%for the software or tools for a minimum of two years from the date of publication. 
%Systematic Biology encourages the use of GPL-like licenses and the use of open repositories, such as SourceForge or Google Code.
%Software for Systematics and Evolution papers should include an abstract. 
%In general, papers will be limited to 4 printed journal pages (less than 12 double-spaced manuscript pages), 
%but exceptions can be made when warranted. We will not enforce any specific organization of the text, 
%but the following suggestions might help in organizing a submission: an introduction that describes the motivation; 
%a Description section; a Benchmark section; a Biological Examples section (if applicable); a statement regarding Availability. 
%However the manuscript is organized, please pay careful attention to the normal formatting 
%for section headings, references, and other aspects of the journalâ€™s style.

\begin{document}
\begin{flushright}
Version dated: \today
\end{flushright}
\bigskip
\noindent RH: Speed dating


\bigskip
\medskip
\begin{center}

% Insert your title:
\noindent{\Large \bf A dynamic programming approach for speed-dating}
\bigskip

% We don't use a special title page; the author information is entered 
% like any other text.

% FOOTNOTES: We don't allow them in the manuscript, except in
% tables. Don't include any footnotes in the text.


\noindent {\normalsize \sc Tom\'{a}\v{s} Flouri$^1$, Emily Jane McTavish$^{1,2}$, Author, Author, Author}\\
\noindent {\small \it 
$^1$Heidelberg Institute for Theoretical Studies, Heidelberg, 69118, Germany\\
$^2$Ecology and Evolutionary Biology, University of Kansas, Lawrence, KS, 66045, USA}\\
\end{center}
\medskip
\noindent{\bf Corresponding author:} Tom\'{a}\v{s} Flouri, 
Heidelberg Institute for Theoretical Studies; Heidelberg, 69118, Germany, E-mail: Tomas.Flouri@h-its.org.\\

% Of course the specific format of addresses may vary according to
% country or other factors. Also, that was just an example email format.
%It's acceptable to add email addresses for authors in addition to the
%corresponding author. These would be placed after "Country."

\vspace{1in}

\subsubsection{Abstract} We present a dynamic programming algorithm to rapidly
date even phylogenies with \ejmcomment{?thousands?} of tips, implemented in the open source software package FastDate. 
This software is capable of using node or tip date prior information to scale trees to absolute time,
or estimate relative times for nodes.
We have implemented recent developments in calculating probabilities of trees accounting for both incomplete 
sampling of species in the present day, and the sampling in the past due to the fossilization and recovery processes.
FastDate is \ejmcomment{(will be)} available on our webserver and source code is on GitHub.\\
\noindent (Keywords: )\\

\vspace{1.5in}

Phylogenetic analyses generate trees with branch lengths in units of expected number of substitutions per site,
whereas downstream analyses may require ultrametric trees or divergence times in years.
For many biological questions it is necessary to have a time scaled tree.
Phylogeographic and paleontological analyses depend upon node dates in absolute time,
in order to associate evolutionary events with historical ones.
Identifying changes in diversification rates, and inferring causes for those changes
relies on accurate estimates of relative speciation times.
\ejmcomment{More on why of dating trees?}

\subsection{Previous approaches}
The most straightforward approach to dating trees assuming that the rate of nucleotide 
substitutions is constant through time, a molecular clock model \cite{zuckerkandl1962}.
However, due to both stochastic variation in observed mutations and 
biological variation in rates of mutation fixation across different lineages,
using a strict molecular clock does not directly generate an ultrametric tree.
There have been many alternative approaches developed to estimate
ultrametric trees using an relaxed clock or correlated rates models (REFS).
In order to scale branch length estimates to time researchers, apply calibration dates. 
There are two main approaches to calibrating phylogenies with known dates:
priors on node ages or tip dates.
Node priors are a distribution the age of a node.
These estimates of node age are often generated from fossils,
but can also be inferred from geological, biogeographical or other information (REF).
Tip dating approaches are usually applied to serially sampled data, i.e. data where some tips were sampled by in the past,
and have known dates.
While tip-date information is most commonly known for bacterial or viral phylogenies,
where samples have been taken at known times,
it is also possible to have use fossil taxa as tips.
These tip dates can either be prior distributions or fixed dates, 
depending on the sampling and the certainty of the date inference.
\citet{Heath2014} developed the fossilized-birth-death model which 
integrates across potential tip placements of fossils
to apply information multiple fossils to better dated phylogenies.

Regardless of the form of date information or priors,
reconciling these dates with branch lengths across the tree is a complex problem.
Several Bayesian methods have been developed which use Markov Chain Monte Carlo (MCMC) methods
to infer dated phylogenies using this prior information, e.g. BEAST (ref)(some various other references)
While these approaches can be accurate, and integrate over uncertainty about the dated
phylogeny, for trees with many tips (>?) or many calibration points, they can be intractably slow. 
\ejmcomment{(REF/is this even true?)}

Some rapid phylogenetic dating approaches have been developed which do not rely on MCMC.
R8s uses non parametric rate smoothing to rapidly estimate maximum likelihood calibrated or ultrametric trees \citep{Sanderson2003}
Least Squares Dating (LSD) (REF Gascuel) 
\ejmcomment{Need to cite but it isn't publicly available anywhere.}
uses a least squares approach based on a normal approximation of the molecular clock.
According to (Gascuel LSD ref) LSD achieves similar results to BEAST, in orders of magnitude shorter times.

\cite{Akerborg2008} describe a dynamic programming approach to 
rapidly estimate ultrametric phylogenies. 
However, this algorithm is not available as an open source implementation.
Our program, FastDate adapted from their dynamic programming algorithm.
Fast Date implements a faster version of the dynamic programming approach running 
in quadratic time instead of the original cubic-time, and instead computes the 
optimal probability density of a sampled tree.
In short, the algorithm maximizes probability of the overall tree using \cite{Stadler2010}'s 
probability of sampled trees with defined node heights,
by building up a table of node height values which maximize the likelihood of 
the node height ($\lambda p_1(t)$),  and the likelihood of branch lengths in the tree 
having a given rate based on the gamma distribution $g(r)$.
In addition it can apply prior information on node dates or \ejmcomment{in future} tip dates to scale the tree to
absolute time.
The granularity of the dating approach can be determined by the user's choice of the number of time intervals to which 
nodes can be assigned and maximum possible root age.
The full procedure is described in depth below.


with the addition of using node and tip date calibrations to scale trees to real time,
and applying recent work on  priors for dates of sampled phylogenies \citep{Stadler2010}.

\section{Methods}

\section {Preliminaries}
%
%
\subsection{Basic definitions}
%
A tree $T=(V,E)$ is a connected acyclic graph where $V$ is the set of {\em
nodes} and $E$ the set of {\em edges}, such that $E = V\times V$. We use the
notation $(u,v) \in E$ to denote an edge with end-points $u,v \in V$. If $T$ is
{\em oriented}, $(u,v) \in E$ indicates that the edge originates at $u$ and leads
to $v$, in which case $u$ is called the {\em parent} and $v$ the {\em child}.
Furthermore, {\em in-degree} (resp. {\em out-degree}) of a node denotes the
number of incoming (resp. outgoing edges) of $u$. In the opposite case, the
{\em degree} of node $u$ denotes the number of edges $u$ is an end-point of.
Further, we denote with $T_u$ the subtree of $T$ rooted at node $u$.  A {\em
rooted binary tree} $T$ is a {\em directed} tree with all nodes having
in-degree 1 and out-degree 1 ({\em inner} nodes), or in-degree 1 and out-degree
0 ({\em leaves}). Furthermore, one node has in-degree 0 and out-degree 2 ({\em
root}).  In the rest of the text we implicitly assume under the term tree a
binary rooted tree.  We denote the set of leaves of tree $T$ as $L(T)$.  The
cardinality of a set $X$ is denoted as $|X|$. The {\em height} $h(u)$ of a node
$u$ of $T$ is defined as 
%
\[ h(u) = \left\{ \begin{array}{ll}
\max(h(v), h(w)) + 1 & \quad : \quad u \notin L(T)\\
1                    & \quad : \quad u    \in L(T)\\
\end{array}\right. \] 
The height $h(T)$ of a tree $T$ is the height of its root.: Finally, we will
use implicitly the notation $\ell_{u,v}$ for the length of edge $(u,v)$.

\subsection{Branch rate distribution}
Setting dates on a tree requires factorizing the branch lengths of an input topology
from estimates of evolutionary distances into rates and times. 
An appropriate expectation for the variation in these branch rates is difficult to select.
A common approximation is to treat branch rates as gamma distributed (REF NEEDED)

The {\em Gamma function} is an extension to the factorial function to handle
any real or complex number as argument. For point $t$ it is defined as
$$\Gamma(t) = \int_0^\infty x^{t-1} e^{-x} dx.$$

The {\em probability density function} in the shape-rate parameterization of a
{\em gamma distribution} given the {\em mean} $\bar{r}$ and variance $\sigma^2$ 
is
$$ \gamma(x;\alpha,\beta) = \frac{\beta^{\alpha}x^{a-1}e^{-x\beta}}{\Gamma(\alpha)} $$

where $\beta = \bar{r} / \sigma^2$ and $\alpha = \bar{r} \beta$.

Its natural logarithm can be computed as
$$ \ln \gamma(x;\alpha,\beta) = \alpha\ln\beta + (\alpha-1)\ln x -x\beta - \ln\Gamma(\alpha) $$

\subsection{Birth-death process}
Phylogenetic trees are commonly modeled using the the constant rate birth\textendash death process \cite{Kendall1948}.
The tree shape is parameterized using simply a per lineage birth rate ($\lambda$) and a per lineage death rate ($\mu$).
$\lambda$ must be greater than $\mu$ or the process deterministically goes to extinction.
Recent work by \citet{Gernhard2008} and \citet{Stadler2009, Stadler2010} has expanded on Kendall's basic 
formulation of the probabilities of birth\textendash death trees to incorporate several important aspects of sampling:
the effect on branch lengths of truncating the process by sampling tips at the present \citep{Gernhard2008},
the effect of incomplete sampling of tips at the present day \citep{Stadler2009}, and the effect of the sampling
of fossils on recovery of ancestral taxa \citep{Stadler2010}.
\citet{Stadler2010} (theorem 3.11) gives probability of a dated topology with $n$ leaves,
under the birth\textendash death process, with some proportion of currently sampled tips 
($\rho$), a rate of recovery of taxa in the past ($\psi$),
and the standard birth and death rate parameters.
We assume two extended types of the {\em constant rate birth-death process}
\cite{Kendall1948} that take into account individuals sampled through time. The
first one takes into account sampling of only extant individuals
\cite{Stadler2009} while the second, which is a generalization of the first,
takes into account extinct individuals \cite{Stadler2010}.

Given a constant birth rate $\lambda$ and a constant death rate $\mu$ such that
$0 \leq \mu < \lambda$. An individual at the present is sampled with
probability $\rho$.  The probability density of a sampled tree $T$ with $n$
extant sampled leaves is given by the formula
%
%
$$f(T|n) = n(\lambda-\mu)\frac{e^{-(\lambda-\mu)x_1}}{\rho\lambda + (\lambda(1 -\rho)-\mu)e^{-(\lambda-\mu)x_1}}\prod_{i=1}^{n-1}
\frac{\lambda\rho(\lambda-\mu)^2e^{-(\lambda-\mu)x_i}}{(\rho\lambda + (\lambda(1-\rho)-\mu)e^{-(\lambda-\mu)x_i})^2}.$$
%
%
The probability density of a sampled tree $T$ with $n$ extant sampled leaves,
$m$ extinct sampled leaves, $n+m > 0$, and $k \geq 0$ sampled individuals with
sampled descendants, conditioned on sampling $n$ present day individuals is
%
%
$$f[T|n,m,k] = \frac{4n\rho\lambda\psi^{k+m}}{c_1(c_2+1)(1-c_2+(1+c_2)e^{c_1x_1})}\prod_{i=1}^{n+m-1}\lambda p_1(x_i)\prod_{i=1}^{m}\frac{p_0(y_i)}{p_1(y_i)}$$
%
%N.B. There is a typo in this equation in \cite{Stadler2010} but logic and Stadler say that last term in denominator is $e^{c_1x_1}$ not  $e^{c_1x}$ \\
%
where $p_0(t)$ is the probability that an individual alive at time $t$ before
present has no sampled extinct or extant descendants, and $p_1(t)$ is the
probability that an individual alive at time $t$ before present has precisely
one sampled extant descendant and no sampled extinct descendant. Those probabilities
are defined as
%
$$p_0(t) = \frac{\lambda+\mu+\psi+c_1\frac{e^{-c_1 t}(1-c_2)-(1+c_2)}{e^{-c_1t}(1-c_2)+(1+c_2)}}{2\lambda}$$
and
$$p_1(t) = \frac{4\rho}{2(1-c_2^2)+e^{-c_1t}(1-c_2)^2+e^{c_1t}(1+c_2)^2}$$
%
and the constants $c_1$ and $c_2$ are defined as
%
$$c_1 = \sqrt{(\lambda-\mu-\psi)^2 + 4\lambda\psi} \qquad c_2 = \frac{\lambda-\mu-2\lambda\rho-\psi}{c_1}$$
%
For more information see \cite{Stadler2010} (Section 3).

%%%%% TODO: Move the following to the DP section %%%%%
%%%%%\begin{enumerate}
%%%%%\item[$\lambda$]  is the per lineage birth (speciation) rate
%%%%%\item[$\mu$]  is the per lineage death (extinction) rate
%%%%%\item[$\psi$]  is the per lineage rate of sampling in the past (e.g. fossils) (in same units as $\lambda$ and $\mu$).
%%%%%\item[$\rho$ ] is the proportion of total extant descendants $N$ which are sampled $n$.
%%%%%\item[$n$] is the number of extant (current) sampled descendants \mthstrike{of a node}.
%%%%%\item[$m$] is the number of extinct (fossil) sampled descendants \mthstrike{of a node}.
%%%%%\item[$c_1,c_2$]  are useful constants.
%%%%%$$c_1 = |\sqrt{(\lambda-\mu-\psi)^2 + 4\lambda\psi}|$$
%%%%%$$c_2 = \frac{\lambda-\mu-2\lambda\rho-\psi}{c_1}$$
%%%%%\end{enumerate}
%%%%%
%%%%%$p_1(t)$ is the probability that an individual alive at time $t$ before today has precisely 1 sampled extant descendants and no sampled extinct descendants.
%%%%%$${p_1}(t) = \frac{4\rho}{2(1-c_2^2)+e^{-c_1t}(1-c_2)^2+e^{c_1t}(1+c_2)^2}$$
%%%%%%And with no sampled fossils ($\psi=0$)
%%%%%%$$f[T|t_{mrca}=x_1,n] = n(\lambda - \mu) \frac{e^{-(\lambda-\mu)x_1}}{\rho\lambda + (\lambda(1-\rho)-\mu)e^{-(\lambda-\mu)x_1}}\prod_{i=1}^{n-1}\frac{\lambda\rho(\lambda-\mu)^2e^{-(\lambda-\mu)x_1}}{(\rho\lambda + (\lambda(1-\rho)-\mu)e^{-(\lambda-\mu)x_1})^2}$$\\
%%%%%
%%%%%For convenience in the algorithm we refer to the first part of $F[T|n]$ as $s(t,n)$.
%%%%%$$s(t,n) = \frac{4n\rho\lambda\psi^{k+m}}{c_1(c_2+1)(1-c_2+(1+c_2)e^{c_1x_1})}$$
%%%%%
%%%%%and the second part as $p_c(v)$.
%%%%%$$p_{c}(v) = \prod_{i=1}^{L(v)-1}\lambda p_1(x_i)$$
%%%%%This is convenient, as we can build up the partial products of the second part of the birth death
%%%%%probability density can be built up as nodes are traversed by
%%%%%the dynamic programming algorithm, and stored for the calculation of $F[T|n]$ at each node.
%%%%%
%%%%%\ejmcomment{Still need to ensure that this is actually how this simplifies out when psi=0}

\section{Dynamic programming algorithm}

We present the dynamic programming algorithm for relative dating of a tree
$T=(V,E)$. This will be extended in the next section to accommodate fossil
information.

We are given an integer $N \geq h(T)$ which we use to construct a grid of
time-lines numbered from 1 to $N$, such that the (uniform) distance between any
two adjacent lines is $1 / (N-1)$ and line $i$ represents time
$\frac{i-1}{N-1}$ in relative time units. The goal is to project each node of
$T$ onto one of the $N$ time-lines using a mapping $\phi : V \mapsto
\{1,\ldots,N\}$ such that a) the score of the formula
%
%
\begin{equation}\label{eq:score}
\begin{split}
f(T\ |\ n,\phi) = & n (\lambda-\mu)
                    \frac {(\lambda\rho)^{n-1} (\lambda-\mu)^{2n-2}
                           e^{-(\lambda-\mu)\tau_r}}
                          {\rho\lambda + 
                           (\lambda(1 -\rho)-\mu)
                           e^{-(\lambda-\mu)\tau_r}} \times  \\
                  & \prod_{u\notin L(T)}\frac{e^{-(\lambda-\mu)\tau_u}}
                                             {(\rho\lambda +
                                              (\lambda(1-\rho)-\mu)
                                              e^{-(\lambda-\mu)\tau_u})^2}
                                        \gamma(\frac{\ell_{u,v}}{\tau_u-\tau_v})
                                        \gamma(\frac{\ell_{u,w}}{\tau_u-\tau_w}).
\end{split}
\end{equation}
%
%
is maximized and b) the following two properties are maintained
%
%
\begin{enumerate}
\item $\forall u,v,w \in V : (u,v), (u,w) \in E \Rightarrow \phi(u) > \phi(v)%
                                                     \wedge \phi(u) > \phi(w)$,
\item $\phi(u) = 1, \forall u \in L(T)$.
\end{enumerate}
%
%
The term $f(T\ |\ n,\phi)$ is the score of tree $T$ for the mapping $\phi$
given the parameters of the birth-death process gamma distribution for
obtaining edge rate probability densities.  The age $\tau_u$ of each inner node
$u$ is computed as $\tau_v = \frac{\phi(u)-1}{N-1}$ and its two edge rates as
$\ell_{u,v}/(\tau_u - \tau_v)$ and $\ell_{u,w}/(\tau_u-\tau_w)$, where $v$ and
$w$ are the two children of $u$.
%
The restriction imposed by Property 1 ensures that no node $v$ in subtree $T_u$
is placed on time-line $\phi(v) \geq \phi(u)$. Property 2 maps all leaves onto
the first time-line.
%
%
%%%\ejmcomment{Not true in case of tip dating, but still currently true. 
%%%Also - we have some inconsistency on whether they are mapped to line 0 or 1.
%%%In the code it is 1 currently.}
%%% TOMAS: For simplicity, I changed the section to describe relative dating only and then
%%% extend it in the next section with fossil information. Therefore, I left property 2 intact.

Before describing the algorithm, it is necessary to define the interval of
discretized time-lines a node can be placed on, such that Property 1 holds. The
interval $d(r)$ for root $r$ is defined as $$d(r) = \{ i\ |\ h(r) \leq i <
N\}$$ and for an arbitrary node $u$ as $$d(u) = \{ i\ |\ h(u) \leq i < \max
d(p); (p,u) \in E\}.$$ This is justified by the fact that the farthest {\em
path} from node $u$ leading to a leaf is of size $h(u)$ and contains exactly
$h(u)$ nodes (including $u$).  Therefore, we require at least $h(u)$ time-lines
for placing each node of the path to a distinct time-line.  Hence, the first
time-line $u$ can be placed on is $h(u)$. The same applies for the path from
$u$ leading to the root node $r$.  Each node must be placed on a distinct
time-line, and as such, the last time-line $u$ may be placed on is one before
the last time-line its parent node $p$ can be placed on. The intervals for each
node can be computed by a preorder traversal of the tree. One method to achieve
maximization of (\ref{eq:score}) is to split $f(T\ |\ n, \phi)$ into two terms
$f_1(T\ |\ n,\phi(r))$ and $f_2(T\ |\ \phi)$
%
%
\begin{equation}\label{eq:part1} 
f_1(T\ |\ n,\phi(r)) = n (\lambda-\mu)
                       \frac{(\lambda\rho)^{n-1}% 
                             (\lambda-\mu)^{2n-2}% 
                             e^{-(\lambda-\mu)\tau_r}}%
                            {\rho\lambda +%
                             (\lambda(1 -\rho)-\mu)%
                             e^{-(\lambda-\mu)\tau_r}}
\end{equation}
%
%
\begin{equation}\label{eq:part2}
f_2(T\ |\ \phi) = \prod_{u\notin L(T)}
                  \frac{e^{-(\lambda-\mu)\tau_u}}
                       {(\rho\lambda + 
                        (\lambda(1-\rho)-\mu)
                        e^{-(\lambda-\mu)\tau_u})^2}
                  \gamma(\frac{\ell_{u,v}}{\tau_u-\tau_v})
                  \gamma(\frac{\ell_{u,w}}{\tau_u-\tau_w}).
\end{equation}
%
%
and compute the $|d(r)|$ maximized values of $f_2(T\ |\ \phi_i), h(r) \leq i
\leq N$, i.e. for each time-line the root may be placed on. Because $f_1(T\ |\
n,\phi)$ depends only on the root time-line, the optimal mapping $\phi_i$ that
maximizes \ref{eq:score} (denoted by $\hat\phi$) is the one that leads to the
highest product $f1_(T\ |\ n,\phi_i)\times f_2(T\ |\ \phi_i)$.%
Our approach is to maximize term \ref{eq:part2} using a dynamic programming
algorithm. For that, we slightly modify the structure of \ref{eq:part2} into
the following equivalent formula, 
%
%
\begin{equation}\label{eq:DP}
\begin{split}
s(u\notin L(T),i) = & \overbrace{\frac{e^{-(\lambda-\mu)\tau_u}}
                                      {(\rho\lambda + 
                                       (\lambda(1-\rho)-\mu)
                                       e^{-(\lambda-\mu)\tau_u})^2}
                      }^{\textrm{birth-death term } b(i)}\times\\
                    & \underbrace{
                        \max\{ s(v,j)\gamma(\frac{(N-1)\ell_{u,v}}{i-j})\ |\ 
                          h(v) \leq j < i\}
                      }_{\textrm{max score of left child}}\times \\
                    & \underbrace{
                        \max\{ s(w,k)\gamma(\frac{(N-1)\ell_{u,w}}{i-k})\ |\ 
                          h(w) \leq k < i\}
                      }_{\textrm{max score of right child}}\\
\end{split}
\end{equation}
%
%
where $s(u\in L(T),1) = 1$.
%
%
The DP traverses the target tree in postorder and for each inner node $u$, it
computes $|d(u)|$ maximized values $s(u,i), h(u) \leq i < h(u) + |d(u)|$, one
for each time-line that node $u$ may be placed on.  The score $s(u,i)$ of a
particular time-line $i$ of node $u$ is computed by finding the time-lines $j$
resp. $k$ of its two children $v$ resp. $w$, which maximize the products of
$s(u,j)$ resp. $s(w,k)$ times the probability densities of the factorized edge
priors $\gamma(\frac{(N-1)l_{u,v}}{i-j})$ resp.
$\gamma(\frac{(N-1)l_{u,w}}{i-k})$.  Note that, for a pair of time-lines $i$
and $j$ resp. $k$, we can factorize the branch length of edge $(u,v)$ resp.
$(u,w)$ into a product of time (age) and rate.
%
%
This results into ${\cal O}((|d(v)|+|d(w)|)\times|d(u)|)$ computations for
determining the $|d(u)|$ maximal scores (and mappings) for $T_u$. These maximal
values for each time-line are then stored in a table together with the
positions (time-lines) its two direct descendants (children) were placed on.
This procedure is repeated recurrently for each node in the tree starting from
the leaves and moving towards the root (postorder).Finally, once the terms
$s(r,i)$ are computed for each time-line of the root node, they are multiplied
with the corresponding term $f_1(T\ |\ n, \phi(r))$, and the time-line yielding
the maximal score is selected.

At this point, the process of backtracking starts, with the goal of retrieving
the optimal mapping $\hat\phi$. By selecting the maximal score (and hence the
time-line of the root) we also obtain the time-lines of its two children, and,
at each of the two children, the time-lines of their two children. Recursively,
we can obtain the time-lines of all nodes that maximize term \ref{eq:score}.
%
Fig.~\ref{fig:dp} describes the algorithm in detail.

\setcounter{instr}{0}
\begin{figure}[t]
\begin{center}
\renewcommand*\arraystretch{.5}
\begin{tabular}{|rl|}
\hline
\multicolumn{2}{|l|}{\textsc{DP}$(T, N, u)$}\\
\ninstr & $v \leftarrow$ left child of $u$\\
\ninstr & $w \leftarrow$ right child of $u$\\
\ninstr & $r \leftarrow$ the root of $T$\\
\ninstr & \textbf{if} $v \in L(T)$ \textbf{then}\\
\ninstr & \qquad $M(v,1) \leftarrow 1$\\
\ninstr & \qquad \textbf{return}\\
\ninstr & \textsc{DP}(T,N,v)\\        
\ninstr & \textbf{if} $w \in L(T)$ \textbf{then}\\
\ninstr & \qquad $M(w,1) \leftarrow 1$\\
\ninstr & \qquad \textbf{return}\\
\ninstr & \textsc{DP}(T,N,w)\\        
\ninstr & \textbf{for} $i \leftarrow \min d(u)$ \textbf{to} $\max d(u)$ \\
\ninstr & \qquad $\hat{f}_u \leftarrow 0, \hat{t}_u \leftarrow (i-1)/(N-1)$\\
\ninstr & \qquad \textbf{for} $j \leftarrow \min d(v)$ \textbf{to} $i-1$ \\
\ninstr & \qquad \qquad  $\tau_v \leftarrow (j-1)/(N-1), r_{u,v} \leftarrow \ell_{u,v}/(\tau_u - \tau_v)$ \\
\ninstr & \qquad \qquad  \textbf{if} $\gamma(r_{u,v})  s(v,j) > \hat{f}_v$ \textbf{then} \\
\ninstr & \qquad \qquad \qquad $\hat{f}_v \leftarrow \gamma(r_{u,v})  s(v,j)$\\
\ninstr & \qquad \qquad \qquad $\hat j \leftarrow j$\\
\ninstr & \qquad \textbf{for} $k \leftarrow \min d(w)$ \textbf{to} $i-1$ \\
\ninstr & \qquad \qquad  $\tau_w \leftarrow (k-1)/(N-1), r_{u,w} \leftarrow \ell_{u,w}/(\tau_u - \tau_w)$\\
\ninstr & \qquad \qquad  \textbf{if} $\gamma(r_{u,w})  s(v,k) > \hat{f}_w$ \textbf{then} \\
\ninstr & \qquad \qquad \qquad $\hat{f}_w \leftarrow \gamma(r_{u,w})  s(w,k)$\\
\ninstr & \qquad \qquad \qquad $\hat k \leftarrow k$\\
\ninstr & \qquad $M(u,i) \leftarrow b(i) \times \hat f_{v} \times \hat f_{w}$\\
\ninstr & \qquad $M^l(u,i) \leftarrow \hat j, M^r(u,i) \leftarrow \hat k$\\
\ninstr & \qquad \textbf{if} $u = r$  \textbf{then}\\
\ninstr & \qquad \qquad $M(u,i) \leftarrow M(u,i) \times f_1(T\ |\ n,i)$ \\

\hline  
\end{tabular}
\end{center}
\caption{The DP algorithm for computing relative divergence times. The
algorithm starts by passing the tree ($T$), number of discretization lines
($N$) and the root of $T$ ($u$). It recursively traverses the tree in
postorder and then computes the best placement for every node $u$.}
\label{fig:dp}
\end{figure}

W.l.o.g we prove that the DP algorithm computes the optimal score of
ref{formula} given the grid size and the values of $\lambda,\mu,\rho,\psi$.

\begin{theorem}[Optimality of DP]
Given the number of discretization intervals, the values of $\lambda,\mu,\rho$,
Algorithm DP computes the optimal score of (\ref{eq:score}).
\end{theorem}
\begin{proof}
We show that the score terms $s(r,i), h(r) \leq i \leq N$ the DP computes are
in fact equal to $f_2(T,\hat\phi_i)$ and hence, finding the product
$f_2(T,\phi_i)\times f_1(T,\phi_i)$ yields the highest value gives us the
optimal solution. We show our proof by strong induction on the height of the
root node.
\paragraph{Base case.} Let $u$ be the parent of $v$ and $w$, such that $h(u) =
1$. Nodes $v$ and $w$ are therefore leaves, which leads us to compute
$|d(u)|=N-1$ values, of the form
%
%
$$
s(u,i) = \frac{e^{-(\lambda - \mu)\tau_u}}
              {(\rho\lambda + (\lambda(1 - \rho) - \mu)
                e^{-(\lambda-\mu)\tau_u})^2}
         \gamma(\frac{\ell_{u,v}}{\tau_u})
         \gamma(\frac{\ell_{u,w}}{\tau_u})
$$
%
%
for each $i \in d(u)$. Since DP selects the score that maximizes the product
when multiplied with $f_1(T,\phi)$, we obtain the optimal score.
\paragraph{Inductive step.} Assume the claim holds for each node $u$ of height
$1 \leq h(u) \leq m$. Our task is to prove that the claim holds for $h(u) =
m+1$.  According to the definition of height, a node $u$ of height $h(u)=m+1$
has a child $v$ of height $h(v)=m$ and a child $w$ of height $0 \leq h(w) \leq
m$.  Since the values $s(v,j), h(v) \leq j \leq \max d(v)$ and $s(w,k), 1 \leq
k \leq \max d(w)$ are maximized (assumption), we compute $|d(u)|$ values
%
%
\begin{equation*}
\begin{split}
s(u,i) = & \frac{e^{-(\lambda-\mu)\tau_u}}
                           {(\rho\lambda + 
                            (\lambda(1-\rho)-\mu)
                            e^{-(\lambda-\mu)\tau_u})^2}\times \\
         & \max\{ s(v,j)\gamma(\frac{(N-1)\ell_{u,v}}{i-j})\ |\ 
               h(v) \leq j < i\} \times \\
         & \max\{ s(w,k)\gamma(\frac{(N-1)\ell_{u,w}}{i-k})\ |\ 
               h(w) \leq k < i\}
\end{split}
\end{equation*}
%
%
and pick the maximal.
\qed\end{proof}

\section{Extending the DP algorithm with node prior information}
To come

\section{Extending the DP algorithm with tip date information}
To come

\section{Description of software}
FastDate requires as input a fully bifurcating rooted phylogeny with branch lengths,
and user defined estimates of birth rate ($\lambda$), death rate ($\mu$), 
and proportion of descendants of the most recent common ancestor of the taxa found in the tree
which were sampled in the tree ($\rho$).
In addition a rate mean ($\bar{r}$) and a rate variance ($\sigma$) must be provided by the user
to parameterize the gamma prior on branch rates.


\subsection{Relative dating}
For relative dating estimates (generating an ultrametric tree),
a number or intervals ($N$) my be provided to control the granularity of 
the relative age estimates.


\subsection{Node prior}
The user can input prior information on node dates in the form of an exponential
or log normal distribution, and a minimum age offset.



\subsection{Tip dating}
\ejmcomment{not yet fully implemented}
Optional parameters include $\psi$ the rate of recovery of fossils per lineage, 
if extinct tips have been sampled.



\section{Examples}
\subsection{Node dating example from 1 KITE}

\subsection{Other tip dating test data from LSD?}

\section{Discussion}

TODO Compare to Gascuel `LSD' and other rapid approaches.



\bibliographystyle{sysbio}
\bibliography{dating}
\end{document}
